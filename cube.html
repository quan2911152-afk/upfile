<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªôp Ch·ªØ Nh·∫≠t 3D Xoay</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>H∆∞·ªõng d·∫´n:</strong><br>
        üñ±Ô∏è K√©o chu·ªôt ƒë·ªÉ xoay h·ªôp<br>
        üé® H·ªôp ch·ªØ nh·∫≠t 3D v·ªõi m√†u s·∫Øc
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, box;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };

        function init() {
            // T·∫°o scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // T·∫°o camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // T·∫°o renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // T·∫°o h·ªôp ch·ªØ nh·∫≠t v·ªõi k√≠ch th∆∞·ªõc kh√°c nhau
            const geometry = new THREE.BoxGeometry(2, 1.5, 1);
            
            // T·∫°o m·∫£ng m√†u cho m·ªói m·∫∑t
            const materials = [
                new THREE.MeshBasicMaterial({ color: 0xff6b6b }), // Ph·∫£i - ƒë·ªè
                new THREE.MeshBasicMaterial({ color: 0x4ecdc4 }), // Tr√°i - xanh lam
                new THREE.MeshBasicMaterial({ color: 0xffe66d }), // Tr√™n - v√†ng
                new THREE.MeshBasicMaterial({ color: 0x95e1d3 }), // D∆∞·ªõi - xanh mint
                new THREE.MeshBasicMaterial({ color: 0xf38181 }), // Tr∆∞·ªõc - h·ªìng
                new THREE.MeshBasicMaterial({ color: 0xaa96da })  // Sau - t√≠m
            ];

            box = new THREE.Mesh(geometry, materials);
            scene.add(box);

            // Th√™m vi·ªÅn cho h·ªôp
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            box.add(wireframe);

            // X·ª≠ l√Ω s·ª± ki·ªán chu·ªôt
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);

            // X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc m√†n h√¨nh
            window.addEventListener('resize', onWindowResize);

            // B·∫Øt ƒë·∫ßu animation
            animate();
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        }

        function onMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            rotation.y += deltaX * 0.01;
            rotation.x += deltaY * 0.01;

            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // √Åp d·ª•ng rotation
            box.rotation.x = rotation.x;
            box.rotation.y = rotation.y;

            renderer.render(scene, camera);
        }

        // Kh·ªüi ƒë·ªông
        init();
    </script>
</body>
</html>